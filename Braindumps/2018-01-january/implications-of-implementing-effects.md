## Effects are Everywhere

In my understanding of the theory of Algebraic Effects, virtually every meaningful business function we would write code for results in some sort of `Effect`.  This includes changing the running state of memory, as well as reading and writing from external services via libraries and system calls, updating UI's, etc.  Also, anything that can throw an exception should be considered an `Effect`. 

Thus, the abstraction of `Effects` and `Handlers` seems extremely fundamental to any system for any codebase that implements it.  As a result, it seems much more practical to design an application on top of them, rather than to try to retrofit existing applications with them.  To do so, developers will need to learn to think about a wide variety of operations and programming problems in terms of these two abstractions.  For developers who write applications using object-oriented or imperative patterns, this is a substantial change of thought.  For developers who have experience with functional programming patterns, it is less so, but still non-trivial.  `Effects` are Monads, but the `Handlers` represent continuation-passing style `CPS`, which does not seem to be common. ([Seeking Other Perspectives Here] (https://github.com/solvingj/eff-algebraic-effect-notes/issues/new))

I have read a substantial amount of literature and code examples, and seen some videos surrounding Algebraic Effects. However, I am only now about to try implementing them in a project.  It will be interesting to see how natural it feels after a few implementations.  It seems like it could feel really simple and natural once one gets the hang of it.  Because of the ubiquity of `Effects`, it also seems like it could become a bit of a golden hammer shortly thereafter.  Conversely, I can imagine there being a traditional learning curve, where developers can improve their use of `Effects` substantially over time, as they continue to work with them and gain hands-on experience. 