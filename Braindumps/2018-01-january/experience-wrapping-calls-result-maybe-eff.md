## Experience with Wrapping Strategies  

In C#, I have previous experience trying to use some very common functional types called `Maybe<T>` and `Result<T>` from a library called [CSharpFunctionalExtensions](https://github.com/vkhorikov/CSharpFunctionalExtensions).    There are some obvious practical similarities with using `Effect`, specifically in that the design is to wrap external-facing calls in them and deal with exceptions and null values with an alternative design pattern.  I spent at least a month wrapping a bunch of system calls and library calls in `try/catch` blocks returning custom `Result` types.  I liked working with Result, and thought it would be a great contribution to the `CSharpFunctionalExtensions` library to releasing supplemental nuget packages with these common wrappers.  At some point, I realizing that all my wrapping in `try/catch` returning `Result<T>` was wildly redundant, unsupportable, and could easily be generalized.  I then created a generic function `Result<T> Try...`  which rendered all these little wrapper projects a huge waste of time.  I later went on to discover that there were at least two other implementations of the same generic `Try` in [language-ext](https://github.com/louthy/language-ext) and [LaYumba.Functional(https://github.com/la-yumba/functional-csharp-code) libraries, which were much more mature and well-tested.  Furthermore, these libraries provided an additional monad in the form of `Exceptional<T>` (which I was also re-inventing), which provides a richer handling of the actual native `Exception` objects that get thrown, whereas `Result<T>` forces you to distill down these `Exception` objects to a simple string. Both have a place, but I don't want to code without an `Exceptional<T>` monad anymore. 

## Lessons Learned
As I lead into trying to use the Effect monad to handle exceptions and external calls, I'll first be trying to understand the "generic pattern" which i can apply universally to all such calls.  

## Meta-Lessons Learned
This was a very enlightening project, although highly inefficient and painful.  It certainly re-enforced my perspective that if you're going to do "alternative" design patterns, use libraries from experts unless you're an expert yourself.  Secondly, it was a good reminder that a formal education in advanced concepts of computer-science is a much more effective route for learning than "self-teaching" (even with good online-learning resources.)  

